[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "mysql.connector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "mysql.connector",
        "description": "mysql.connector",
        "isExtraImport": true,
        "detail": "mysql.connector",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "db_config",
        "importPath": "config_source",
        "description": "config_source",
        "isExtraImport": true,
        "detail": "config_source",
        "documentation": {}
    },
    {
        "label": "db_config_destination",
        "importPath": "config_destination",
        "description": "config_destination",
        "isExtraImport": true,
        "detail": "config_destination",
        "documentation": {}
    },
    {
        "label": "db_config_destination",
        "kind": 5,
        "importPath": "config_destination",
        "description": "config_destination",
        "peekOfCode": "db_config_destination = {\n    'host': os.getenv('DB_HOST'),\n    'user': os.getenv('DB_USER'),\n    'password': os.getenv('DB_PASSWORD'),\n    'database': os.getenv('DB_NAME2')\n}",
        "detail": "config_destination",
        "documentation": {}
    },
    {
        "label": "db_config",
        "kind": 5,
        "importPath": "config_source",
        "description": "config_source",
        "peekOfCode": "db_config = {\n    'host': os.getenv('DB_HOST'),\n    'user': os.getenv('DB_USER'),\n    'password': os.getenv('DB_PASSWORD'),\n    'database': os.getenv('DB_NAME')\n}",
        "detail": "config_source",
        "documentation": {}
    },
    {
        "label": "get_weighted_time_of_day",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def get_weighted_time_of_day():\n    time_of_day_weights = {\n        \"00:00-04:00\": 2,    # Early morning, less likely\n        \"04:00-06:00\": 5,    # Early morning\n        \"06:00-09:00\": 15,   # Morning commute\n        \"09:00-12:00\": 25,   # Morning work hours\n        \"12:00-15:00\": 30,   # Afternoon work hours\n        \"15:00-18:00\": 35,   # Evening commute\n        \"18:00-21:00\": 50,   # Evening leisure time, most likely\n        \"21:00-23:59\": 20    # Late evening",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "generate_random_timestamp",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def generate_random_timestamp():\n    random_date = datetime.now() - timedelta(days=random.randint(0, 365))\n    random_time = get_weighted_time_of_day()\n    return datetime.combine(random_date.date(), random_time)\n# Global flag to indicate if the program should exit\nshould_exit = False\ndef signal_handler(signum, frame):\n    global should_exit\n    print(\"\\nReceived exit signal. Finishing current iteration and exiting...\")\n    should_exit = True",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def signal_handler(signum, frame):\n    global should_exit\n    print(\"\\nReceived exit signal. Finishing current iteration and exiting...\")\n    should_exit = True\n# Set up the signal handler\nsignal.signal(signal.SIGINT, signal_handler)\ndef clear_console():\n    if os.name == 'nt':\n        _ = os.system('clear')\ndef connect_to_database(db_config):",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "clear_console",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def clear_console():\n    if os.name == 'nt':\n        _ = os.system('clear')\ndef connect_to_database(db_config):\n    return mysql.connector.connect(**db_config)\ndef fetch_data_from_database(connection, limit=1000):\n    cursor = connection.cursor(dictionary=True)\n    cursor.execute(\"\"\"\n    SELECT *, `release` AS `release_date` \n    FROM songs ",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "connect_to_database",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def connect_to_database(db_config):\n    return mysql.connector.connect(**db_config)\ndef fetch_data_from_database(connection, limit=1000):\n    cursor = connection.cursor(dictionary=True)\n    cursor.execute(\"\"\"\n    SELECT *, `release` AS `release_date` \n    FROM songs \n    ORDER BY RAND() \n    LIMIT %s\n    \"\"\", (limit,))",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "fetch_data_from_database",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def fetch_data_from_database(connection, limit=1000):\n    cursor = connection.cursor(dictionary=True)\n    cursor.execute(\"\"\"\n    SELECT *, `release` AS `release_date` \n    FROM songs \n    ORDER BY RAND() \n    LIMIT %s\n    \"\"\", (limit,))\n    return cursor.fetchall()\n# Option 2: Ensuring that some users listen to multiple songs",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "generate_random_events",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def generate_random_events(num_events):\n    events = []\n    # Event types and distributions\n    event_types = {\n        \"streamed song\": 65, \n        \"added to playlist\": 10, \n        \"removed from playlist\": 5, \n        \"liked song\": 15, \n        \"disliked song\": 5\n    }",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "combine_data_and_events",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def combine_data_and_events(data, events):\n    combined = []\n    for record in data:\n        record_events = random.sample(events, random.randint(1, min(5, len(events))))\n        combined.append({\n            \"record\": record,\n            \"events\": record_events\n        })\n    return combined\ndef create_connection(db_config):",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "create_connection",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def create_connection(db_config):\n    try:\n        connection = mysql.connector.connect(**db_config)\n        return connection\n    except mysql.connector.Error as e:\n        print(f\"Error connecting to MySQL database: {e}\")\n        return None\ndef write_to_event_sim_db(data, connection):\n    try:\n        cursor = connection.cursor()",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "write_to_event_sim_db",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def write_to_event_sim_db(data, connection):\n    try:\n        cursor = connection.cursor()\n        # Create the events table if it doesn't exist\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS `events` (\n            `id` INT AUTO_INCREMENT PRIMARY KEY,\n            `event_type` VARCHAR(50),\n            `timestamp` DATETIME,\n            `user_id` INT,",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "run_simulation",
        "kind": 2,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "def run_simulation(db_config, db_config_destination):\n    global should_exit\n    connection_source = create_connection(db_config)\n    connection_destination = create_connection(db_config_destination)\n    if not connection_source or not connection_destination:\n        print(\"Failed to establish database connections. Exiting.\")\n        return\n    total_iterations = 1 * 30  # 30 hours * 30 files per hour\n    try:\n        for i in range(total_iterations):",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "should_exit",
        "kind": 5,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "should_exit = False\ndef signal_handler(signum, frame):\n    global should_exit\n    print(\"\\nReceived exit signal. Finishing current iteration and exiting...\")\n    should_exit = True\n# Set up the signal handler\nsignal.signal(signal.SIGINT, signal_handler)\ndef clear_console():\n    if os.name == 'nt':\n        _ = os.system('clear')",
        "detail": "eventsim",
        "documentation": {}
    },
    {
        "label": "user_id_pool",
        "kind": 5,
        "importPath": "eventsim",
        "description": "eventsim",
        "peekOfCode": "user_id_pool = [random.randint(1, 1000) for _ in range(100)]  # Create a pool of 100 user IDs\ndef generate_random_events(num_events):\n    events = []\n    # Event types and distributions\n    event_types = {\n        \"streamed song\": 65, \n        \"added to playlist\": 10, \n        \"removed from playlist\": 5, \n        \"liked song\": 15, \n        \"disliked song\": 5",
        "detail": "eventsim",
        "documentation": {}
    }
]